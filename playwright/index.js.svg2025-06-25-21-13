const express = require('express');
const { chromium } = require('playwright');
const fs = require('fs');
const path = require('path');

const app = express();
const port = 3000;

const createLocalFile = process.env.CREATE_LOCAL_FILE === 'false';

app.use(express.json());

app.post('/render', async (req, res) => {
  const { url } = req.body;
  console.log('ðŸ“¥ RequÃªte reÃ§ue avec body brut :', req.body);
  console.log('ðŸŒ URL extraite :', url);

  if (!url) return res.status(400).send('Missing URL');

  console.log('â–¶ï¸ RequÃªte reÃ§ue pour URL :', url);

  let browser;
  let context;

  try {
    browser = await chromium.launch();
    context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
    });

    await context.addInitScript(() => {
      Object.defineProperty(navigator, 'webdriver', {
        get: () => false,
      });
    });

    const page = await context.newPage();

    await page.goto(url, { waitUntil: 'networkidle' });
    console.log('âœ… Page principale chargÃ©e');

    try {
      const acceptButton = await page.waitForSelector('button[name="agree"]', { timeout: 3000 });
      if (acceptButton) {
        await acceptButton.click();
        console.log('ðŸª Bouton "Accepter tous" cliquÃ©');
        await page.waitForTimeout(1000);
      }
    } catch (e) {
      console.log('â„¹ï¸ Aucun bouton de cookies trouvÃ© ou timeout dÃ©passÃ©');
    }

    await page.setViewportSize({ width: 1920, height: 1080 });
    await page.emulateMedia({ reducedMotion: 'reduce' });

    await page.evaluate(async () => {
      await new Promise((resolve) => {
        let totalHeight = 0;
        const distance = 100;
        const timer = setInterval(() => {
          window.scrollBy(0, distance);
          totalHeight += distance;
          if (totalHeight >= document.body.scrollHeight) {
            clearInterval(timer);
            resolve();
          }
        }, 100);
      });
    });

    await page.waitForTimeout(500);

    const screenshotPath = path.join(__dirname, 'outputs', 'last_screenshot.png');
    if (!fs.existsSync(path.dirname(screenshotPath))) {
      fs.mkdirSync(path.dirname(screenshotPath), { recursive: true });
    }

    try {
      await page.screenshot({
        path: screenshotPath,
        fullPage: true,
        timeout: 60000,
      });
      console.log('ðŸ“¸ Screenshot capturÃ© :', screenshotPath);
    } catch (e) {
      console.error('âŒ Ã‰chec de la capture dâ€™Ã©cran :', e);
    }

    const frames = page.frames();
    console.log('ðŸ” Frames dÃ©tectÃ©s :');
    frames.forEach(f => console.log(' - ', f.url()));

    const frame = frames.find(f => f.url().includes('multi_event.php') && f.url().includes('multi='));

    let htmlContent;
    if (frame) {
      console.log('ðŸ”— Iframe ciblÃ©e trouvÃ©e :', frame.url());

      await frame.evaluate(async () => {
        await new Promise((resolve) => {
          let totalHeight = 0;
          const distance = 100;
          const timer = setInterval(() => {
            window.scrollBy(0, distance);
            totalHeight += distance;
            if (totalHeight >= document.body.scrollHeight) {
              clearInterval(timer);
              resolve();
            }
          }, 200);
        });
      });

      await page.waitForTimeout(3000);
      htmlContent = await frame.content();
    } else {
      console.log('âš ï¸ Aucune iframe spÃ©cifique trouvÃ©e, fallback sur le contenu principal');
      await page.waitForTimeout(2000);
      htmlContent = await page.content();
    }

    console.log('ðŸ“¦ HTML rÃ©cupÃ©rÃ©, taille :', htmlContent.length);

    if (createLocalFile) {
      const fileName = url.replace(/[^a-z0-9]/gi, '_').toLowerCase();
      const filePath = path.join(__dirname, `${fileName}.html`);
      fs.writeFileSync(filePath, htmlContent);
      console.log(`ðŸ’¾ Fichier HTML sauvegardÃ© : ${filePath}`);

      const now = new Date();
      const timestamp = now.toISOString().replace(/T/, '-').replace(/:/g, '-').split('.')[0];
      const datedFileName = `playwright-result_${timestamp}.html`;
      const datedFilePath = path.join(__dirname, 'outputs', datedFileName);
      if (!fs.existsSync(path.dirname(datedFilePath))) {
        fs.mkdirSync(path.dirname(datedFilePath), { recursive: true });
      }
      fs.writeFileSync(datedFilePath, htmlContent);
      console.log(`ðŸ’¾ Fichier HTML horodatÃ© sauvegardÃ© : ${datedFilePath}`);
    } else {
      console.log('ðŸš« CREATE_LOCAL_FILE dÃ©sactivÃ©, aucun fichier sauvegardÃ©');
    }

    res.send(htmlContent);
  } catch (error) {
    console.error('âŒ Erreur :', error);
    res.status(500).send('Erreur lors du rendu');
  } finally {
    try {
      if (context) await context.close();
    } catch (e) {
      console.error('âš ï¸ Erreur lors de la fermeture du context :', e);
    }

    try {
      if (browser) await browser.close();
    } catch (e) {
      console.error('âš ï¸ Erreur lors de la fermeture du navigateur :', e);
    }

    console.log('ðŸ§¹ Navigateur fermÃ©');
  }
});

app.listen(port, () => {
  console.log(`âœ… API Playwright en Ã©coute sur http://localhost:${port}`);
});
